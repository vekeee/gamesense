local clipboard = require("gamesense/clipboard") or error("Missing Clipboard: https://gamesense.pub/forums/viewtopic.php?id=28678", 2)
local base64 = require("gamesense/base64") or error("Missing Base64: https://gamesense.pub/forums/viewtopic.php?id=21619", 2)
local vector = require("vector") or error("Missing Vector", 2)
local ffi = require("ffi") or error("Please turn on Allow unsafe scripts!", 2)
local http = require("gamesense/http") or error("Missing http: https://gamesense.pub/forums/viewtopic.php?id=19253", 2)

local defr, defg, defb, defa = 191, 191, 236, 255

local function gradient_rgb(r1, g1, b1, a1, text)
    if #text == 0 then
        return "" -- Return an empty string if the text is empty
    end

    local r2, g2, b2, a2 = 255, 255, 255, 255 -- Default final RGB and A values
    local output = ""
    local len = #text - 1
    if len <= 0 then
        -- If the text length is too short, handle it accordingly
        return ("\a%02x%02x%02x%02x%s"):format(r1, g1, b1, a1, text)
    end

    local rinc = (r2 - r1) / len
    local ginc = (g2 - g1) / len
    local binc = (b2 - b1) / len
    local ainc = (a2 - a1) / len

    for i = 1, len + 1 do
        output = output .. ("\a%02x%02x%02x%02x%s"):format(r1, g1, b1, a1, text:sub(i, i))
        r1 = r1 + rinc
        g1 = g1 + ginc
        b1 = b1 + binc
        a1 = a1 + ainc
    end

    return output
end

local text_to_slidedraw = {
    one = "%s"
}

local function slidetoHex(value)
    local hexChars = "0123456789ABCDEF"
    local output = ""
    
    while value > 0 do
        local index = value % 16 + 1
        value = math.floor(value / 16)
        output = string.sub(hexChars, index, index) .. output
    end
    
    if #output == 0 then 
        output = "00" 
    elseif #output == 1 then 
        output = "0" .. output 
    end 
    
    return output
end

local function slideconvertToHex(arg)
    local result = "\a"
    
    for _, value in ipairs(arg) do
        result = result .. slidetoHex(value)
    end 
    
    return result .. "FF"
end

local lua_enable = ui.new_label("AA", "Anti-aimbot angles", "%s")
local function gradient_rgbslide()
	if not ui.is_menu_open() then return nil end
    local textToDraw = "(v4.5) nemesis"
    local r2, g2, b2, a2 = defr, defg, defb, defa
    local highlightFraction = (globals.realtime() / 2 % 1.2 * 2) - 1.2
    local formattedText = ""

    for idx = 1, #textToDraw do
        local character = textToDraw:sub(idx, idx)
        local characterFraction = idx / #textToDraw
        local r1, g1, b1, a1 = 255, 255, 255, 255
        local highlightDelta = (characterFraction - highlightFraction)

        if highlightDelta >= 0 and highlightDelta <= 1.4 then
            if highlightDelta > 0.7 then
                highlightDelta = 1.4 - highlightDelta
            end

            local rFraction, gFraction, bFraction = r2 - r1, g2 - g1, b2 - b1
            r1 = r1 + rFraction * highlightDelta / 0.8
            g1 = g1 + gFraction * highlightDelta / 0.8
            b1 = b1 + bFraction * highlightDelta / 0.8
        end

        formattedText = formattedText .. ('\a%02x%02x%02x%02x%s'):format(r1, g1, b1, 255, character)
    end
    
    ui.set(lua_enable, "‚ùñ " ..text_to_slidedraw.one:format(formattedText))
end

local refs = {
	enabled = ui.reference("AA", "Anti-aimbot angles", "Enabled"),
	pitch = {ui.reference("AA", "Anti-aimbot angles", "pitch")},
	roll = ui.reference("AA", "Anti-aimbot angles", "roll"),
	yawbase = ui.reference("AA", "Anti-aimbot angles", "Yaw base"),
	yaw = {ui.reference("AA", "Anti-aimbot angles", "Yaw")},
	fsbodyyaw = ui.reference("AA", "anti-aimbot angles", "Freestanding body yaw"),
	edgeyaw = ui.reference("AA", "Anti-aimbot angles", "Edge yaw"),
	maxproccessticks = ui.reference("MISC", "Settings", "sv_maxusrcmdprocessticks2"),
	yawjitter = {ui.reference("AA", "Anti-aimbot angles", "Yaw jitter")},
	bodyyaw = {ui.reference("AA", "Anti-aimbot angles", "Body yaw")},
	freestand = {ui.reference("AA", "Anti-aimbot angles", "Freestanding")},
	onshotaa = {ui.reference("AA", "Other", "On shot anti-aim")},
	slowmotion = {ui.reference("AA", "Other", "Slow motion")},
	doubletap = {ui.reference("RAGE", "Aimbot", "Double tap")},
	leg_movement = ui.reference("AA", "Other", "Leg movement"),
    minimumdamageoverride = {ui.reference("RAGE", "Aimbot", "Minimum damage override")},
	fakelag = ui.reference("AA", "Fake lag", "Enabled"),
	fakeduck = ui.reference("RAGE", "Other", "Duck peek assist"),
	clantag = ui.reference("MISC", "Miscellaneous", "Clan tag spammer")
}

local state_vars = {
    player_states = {"stand", "move", "slowwalk", "air", "duck", "airduck", "fakelag"},

    state_int = {
        stand = 1,
        move = 2,
        slowwalk = 3,
        air = 4,
        duck = 5,
        airduck = 6,
		fakelag = 7
    },

    state_to_int = {
        S = 1,
        M = 2,
        SW = 3,
        A = 4,
        D = 5,
        AD = 6,
		FL = 7
    },

    short_player_states = {"S", "M", "SW", "A", "D", "AD", "FL"},

    player_state_holder = 1
}

local function does_contain(tbl, val)
    for i=1, #tbl do
        if tbl[i] == val then
            return true
        end
    end
    return false
end

local defhex = nil

local main_colour = ui.new_color_picker("AA", "Anti-aimbot angles", "main colour", 191, 191, 236, 255)

rgba_to_hex = function(b, c, d, e)
    return string.format('%02x%02x%02x%02x', b, c, d, e)
end

local function processColor(main_colour)
    local r, g, b, a = ui.get(main_colour)
    return r, g, b, a
end

local function getcolour()
    local rr, gg, bb = processColor(main_colour)
    defhex = "\a"..rgba_to_hex(rr, gg, bb, 255)..""
end

getcolour()

local lua_menu = ui.new_slider("AA", "Anti-aimbot angles", "\n", 1, 4, 1, true, '', 1, { [2] = defhex..'‚ôØ \aFFFFFFFFanti-aimbot '..defhex..'‚ôØ', [1] = defhex..'‚ôØ \aFFFFFFFFaimbot', [3] = defhex..'‚ôØ \aFFFFFFFFvisuals '..defhex..'‚ôØ', [4] = defhex..'\aFFFFFFFFmiscellaneous '..defhex..'‚ôØ'})
local lua_menu_spacer = ui.new_label("AA", "Anti-aimbot angles", "\n")

local fl_reset = ui.new_checkbox("AA", "Anti-aimbot angles", "enable ‚Ä¢ "..defhex.."reset fakelag on land")

local antiaim_state = ui.new_checkbox("AA", "Anti-aimbot angles", "enable ‚Ä¢ "..defhex.."anti-aim")

local Builder = {}
local builder_spacer = ui.new_label("AA", "Anti-aimbot angles", "\n")
local defensive = ui.new_checkbox("AA", "Anti-aimbot angles", "enable ‚Ä¢ "..defhex.."exploit tickbase")
local dis_jitter = ui.new_checkbox("AA", "Anti-aimbot angles", "enable ‚Ä¢ "..defhex.."static freestanding")
local flick_fs = ui.new_checkbox("AA", "Anti-aimbot angles", "enable ‚Ä¢ "..defhex.."flicker freestanding")
local freestand_key = ui.new_hotkey("AA", "Anti-aimbot angles", defhex.."freestanding")
local current_state_select = ui.new_combobox("AA", "Anti-aimbot angles", "\n", "stand", "move", "slowwalk", "air", "duck", "airduck", "fakelag")
local builder_label = ui.new_label("AA", "Anti-aimbot angles", "\n")

for i=1, 7 do
	Builder[i] = {
		pitch = ui.new_combobox("AA", "Anti-aimbot angles","pitch ‚Ä¢ "..gradient_rgb(defr, defg, defb, defa, "mode").."\a0000000"..state_vars.player_states[i], "minimal", "up", "spam", "flicker"),
		yaw = ui.new_combobox("AA", "Anti-aimbot angles","yaw ‚Ä¢ "..gradient_rgb(defr, defg, defb, defa, "mode").."\a0000000"..state_vars.player_states[i], "l + r", "spam", "delay"),
		unsafedelay = ui.new_checkbox("AA", "Anti-aimbot angles","unsafe ‚Ä¢ "..gradient_rgb(defr, defg, defb, defa, "mode").."\a0000000"..state_vars.player_states[i]),
		yawleft = ui.new_slider("AA", "Anti-aimbot angles","yaw ‚Ä¢ "..gradient_rgb(defr, defg, defb, defa, "left").."\a0000000"..state_vars.player_states[i], -180, 180, 0),
		yawright = ui.new_slider("AA", "Anti-aimbot angles","yaw ‚Ä¢ "..gradient_rgb(defr, defg, defb, defa, "right").."\a0000000"..state_vars.player_states[i], -180, 180, 0),
		yawjitter = ui.new_combobox("AA", "Anti-aimbot angles","jitter ‚Ä¢ "..gradient_rgb(defr, defg, defb, defa, "mode").."\a0000000"..state_vars.player_states[i], "off", "center"),
		jitterdisabled = ui.new_label("AA", "Anti-aimbot angles", "\aa8a85fffyaw jitter can not be used with delay yaw"),
		jitterdisabled1 = ui.new_label("AA", "Anti-aimbot angles", "\aa8a85fffunless unsafe mode used!"),
		yawjitterslider = ui.new_slider("AA", "Anti-aimbot angles", "\n \a0000000"..state_vars.player_states[i], 0, 180, 0),
		bodyoptions = ui.new_combobox("AA", "Anti-aimbot angles","body ‚Ä¢ "..gradient_rgb(defr, defg, defb, defa, "mode").."\a0000000"..state_vars.player_states[i], "off", "jitter", "opposite", "static"),
		bodyoptionsslider = ui.new_slider("AA", "Anti-aimbot angles","\n"..state_vars.player_states[i], -180, 180, 0),
		bodydisabled = ui.new_label("AA", "Anti-aimbot angles", "\aa8a85fffbody options can not be used with delay yaw"),
		bodydisabled1 = ui.new_label("AA", "Anti-aimbot angles", "\aa8a85fffunless unsafe mode used!")
	}
end

local main_colour_note = ui.new_label("AA", "Anti-aimbot angles", "\aa8a85fffnote: main colour does not affect menu colour")
local clrvis_label = ui.new_label("AA", "Anti-aimbot angles", "\n")
local watermark = ui.new_checkbox("AA", "Anti-aimbot angles", "enable ‚Ä¢ "..defhex.."watermark")
local indicators = ui.new_multiselect("AA", "Anti-aimbot angles", "enable ‚Ä¢ "..defhex.."indicators", "minimum damage", "lag compensation")
local clantag = ui.new_checkbox("AA", "Anti-aimbot angles", "enable ‚Ä¢ "..defhex.."clan tag spammer")

local antibackstab = ui.new_checkbox("AA", "Anti-aimbot angles", "enable ‚Ä¢ "..defhex.."avoid backstab")
local shittalk = ui.new_checkbox("AA", "Anti-aimbot angles", "enable ‚Ä¢ "..defhex.."chat spammer")
local hitlogs = ui.new_checkbox("AA", "Anti-aimbot angles", "enable ‚Ä¢ "..defhex.."shot logger")
local animbrk = ui.new_checkbox("AA", "Anti-aimbot angles", "enable ‚Ä¢ "..defhex.."leg movement")
local animbrkwhat = ui.new_combobox("AA", "Anti-aimbot angles", "\n", "-", "modern", "moonwalk")
local animbrkpitch = ui.new_combobox("AA", "Anti-aimbot angles", "\n", "-", "0 pitch", "0 pitch random")

local function og_apply(state)
	ui.set_visible(refs.enabled, state)
	ui.set_visible(refs.pitch[1], state)
	ui.set_visible(refs.pitch[2], state)
	ui.set_visible(refs.roll, state)
	ui.set_visible(refs.yawbase, state)
	ui.set_visible(refs.yaw[1], state)
	ui.set_visible(refs.yaw[2], state)
	ui.set_visible(refs.yawjitter[1], state)
	ui.set_visible(refs.yawjitter[2], state)
	ui.set_visible(refs.bodyyaw[1], state)
	ui.set_visible(refs.bodyyaw[2], state)
	ui.set_visible(refs.freestand[1], state)
	ui.set_visible(refs.freestand[2], state)
	ui.set_visible(refs.fsbodyyaw, state)
	ui.set_visible(refs.edgeyaw, state)
end

local function lua_apply()
	state_vars.active_section = state_vars.state_int[ui.get(current_state_select)]
	local is_aa = ui.get(lua_menu) == 2
	local is_rage = ui.get(lua_menu) == 1
	local is_vis = ui.get(lua_menu) == 3
	local is_misc = ui.get(lua_menu) == 4
	local is_aabden = ui.get(antiaim_state)

	if is_rage then
		ui.set_visible(fl_reset, true)
	else
		ui.set_visible(fl_reset, false)
	end

	if is_aa then
		ui.set_visible(antiaim_state, true)
		ui.set_visible(freestand_key, true)
		ui.set_visible(current_state_select, true)
	else
		ui.set_visible(antiaim_state, false)
		ui.set_visible(freestand_key, false)
		ui.set_visible(current_state_select, false)
	end

	if is_vis then
		ui.set_visible(watermark, true)
		ui.set_visible(indicators, true)
		ui.set_visible(clrvis_label, true)
		ui.set_visible(clantag, true)
		ui.set_visible(main_colour_note, true)
	else
		ui.set_visible(watermark, false)
		ui.set_visible(indicators, false)
		ui.set_visible(clrvis_label, false)
		ui.set_visible(clantag, false)
		ui.set_visible(main_colour_note, false)
	end

	if is_misc then
		ui.set_visible(antibackstab, true)
		ui.set_visible(hitlogs, true)
		ui.set_visible(animbrk, true)
		ui.set_visible(shittalk, true)
	else
		ui.set_visible(antibackstab, false)
		ui.set_visible(hitlogs, false)
		ui.set_visible(animbrk, false)
		ui.set_visible(shittalk, false)
	end

	if is_misc and ui.get(animbrk) then
		ui.set_visible(animbrkwhat, true)
		ui.set_visible(animbrkpitch, true)
	else
		ui.set_visible(animbrkwhat, false)
		ui.set_visible(animbrkpitch, false)
	end

	if is_aabden then
		for i=1, 7 do
			ui.set_visible(current_state_select, is_aa)
			ui.set_visible(builder_spacer, is_aa)
			if is_aabden then
				ui.set_visible(defensive, is_aa)
				ui.set_visible(freestand_key, is_aa)
				ui.set_visible(dis_jitter, is_aa)
				ui.set_visible(builder_label, is_aa)
				ui.set_visible(flick_fs, is_aa)
				ui.set_visible(Builder[i].pitch, state_vars.active_section == i and is_aa)
				ui.set_visible(Builder[i].unsafedelay, state_vars.active_section == i and is_aa)
				ui.set_visible(Builder[i].yaw, state_vars.active_section == i and is_aa)
				ui.set_visible(Builder[i].yawleft, state_vars.active_section == i and ui.get(Builder[state_vars.active_section].yaw) ~= "spam" and is_aa)
				ui.set_visible(Builder[i].yawright, state_vars.active_section == i and ui.get(Builder[state_vars.active_section].yaw) ~= "spam" and is_aa)
				ui.set_visible(Builder[i].yawjitter, state_vars.active_section == i and is_aa)
				ui.set_visible(Builder[i].yawjitterslider, state_vars.active_section == i and ui.get(Builder[state_vars.active_section].yawjitter) ~= "off" and is_aa)
				ui.set_visible(Builder[i].jitterdisabled, state_vars.active_section == i and ui.get(Builder[state_vars.active_section].yaw) == "delay" and is_aa)
				ui.set_visible(Builder[i].jitterdisabled1, state_vars.active_section == i and ui.get(Builder[state_vars.active_section].yaw) == "delay" and is_aa)
				ui.set_visible(Builder[i].bodyoptions, state_vars.active_section == i and is_aa)
				ui.set_visible(Builder[i].bodyoptionsslider, state_vars.active_section == i and ui.get(Builder[i].bodyoptions) ~= "off" and ui.get(Builder[i].bodyoptions) ~= "opposite" and ui.get(Builder[i].bodyoptions) ~= "jitter" and is_aa)
				ui.set_visible(Builder[i].bodydisabled, state_vars.active_section == i and ui.get(Builder[state_vars.active_section].yaw) == "delay" and is_aa)
				ui.set_visible(Builder[i].bodydisabled1, state_vars.active_section == i and ui.get(Builder[state_vars.active_section].yaw) == "delay" and is_aa)
			else
				ui.set_visible(defensive, false)
				ui.set_visible(freestand_key, false)
				ui.set_visible(dis_jitter, false)
				ui.set_visible(builder_label, false)
				ui.set_visible(flick_fs, false)
				ui.set_visible(Builder[i].pitch, false)
				ui.set_visible(Builder[i].unsafedelay, false)
				ui.set_visible(Builder[i].yaw, false)
				ui.set_visible(Builder[i].yawleft, false)
				ui.set_visible(Builder[i].yawright, false)
				ui.set_visible(Builder[i].yawjitter, false)
				ui.set_visible(Builder[i].yawjitterslider, false)
				ui.set_visible(Builder[i].jitterdisabled, false)
				ui.set_visible(Builder[i].jitterdisabled1, false)
				ui.set_visible(Builder[i].bodyoptions, false)
				ui.set_visible(Builder[i].bodyoptionsslider, false)
				ui.set_visible(Builder[i].bodydisabled, false)
				ui.set_visible(Builder[i].bodydisabled1, false)
			end
		end
	else
		for i=1, 7 do
			ui.set_visible(builder_spacer, false)
			ui.set_visible(defensive, false)
			ui.set_visible(freestand_key, false)
			ui.set_visible(dis_jitter, false)
			ui.set_visible(builder_label, false)
			ui.set_visible(flick_fs, false)
			ui.set_visible(current_state_select,false)
			ui.set_visible(Builder[i].pitch, false)
			ui.set_visible(Builder[i].unsafedelay, false)
			ui.set_visible(Builder[i].yaw, false)
			ui.set_visible(Builder[i].yawleft, false)
			ui.set_visible(Builder[i].yawright, false)
			ui.set_visible(Builder[i].yawjitter, false)
			ui.set_visible(Builder[i].yawjitterslider, false)
			ui.set_visible(Builder[i].jitterdisabled, false)
			ui.set_visible(Builder[i].jitterdisabled1, false)
			ui.set_visible(Builder[i].bodyoptions, false)
			ui.set_visible(Builder[i].bodyoptionsslider, false)
			ui.set_visible(Builder[i].bodydisabled, false)
			ui.set_visible(Builder[i].bodydisabled1, false)
		end
	end
end

local logs = {}
local dynamic = {}
dynamic.__index = dynamic function dynamic.new(f, z, r, xi) f = math.max(f, 0.001) z = math.max(z, 0) local pif = math.pi * f local twopif = 2 * pif local a = z / pif local b = 1 / ( twopif * twopif ) local c = r * z / twopif return setmetatable({ a = a, b = b, c = c, px = xi, y = xi, dy = 0 }, dynamic) end function dynamic:update(dt, x, dx) if dx == nil then dx = ( x - self.px ) / dt self.px = x end self.y = self.y + dt * self.dy self.dy = self.dy + dt * ( x + self.c * dx - self.y - self.a * self.dy ) / self.b return self end function dynamic:get() return self.y end local function roundedRectangle(b, c, d, e, f, g, h, i, j, k) renderer.rectangle(b, c, d, e, f, g, h, i) renderer.circle(b, c, f - 8, g - 8, h - 8, i, k, -180, 0.25) renderer.circle(b + d, c, f - 8, g - 8, h - 8, i, k, 90, 0.25) renderer.rectangle(b, c - k, d, k, f, g, h, i) renderer.circle(b + d, c + e, f - 8, g - 8, h - 8, i, k, 0, 0.25) renderer.circle(b, c + e, f - 8, g - 8, h - 8, i, k, -90, 0.25) renderer.rectangle(b, c + e, d, k, f, g, h, i) renderer.rectangle(b - k, c, k, e, f, g, h, i) renderer.rectangle(b + d, c, k, e, f, g, h, i) end

client.set_event_callback('paint', function()
    local screen = {client.screen_size()}
    for i = 1, #logs do
        if not logs[i] then return end
        if not logs[i].init then
            logs[i].y = dynamic.new(2, 2, 0.01, -10)
            logs[i].time = globals.tickcount() + 164
            logs[i].init = true
        end

        local rr, gg, bb = logs[i].rr, logs[i].gg, logs[i].bb
        local string_size = renderer.measure_text("c", logs[i].text)
		
		roundedRectangle(screen[1]/2-string_size/2-25, screen[2]-logs[i].y:get(), string_size+10, 16, rr, gg, bb, 35,"", 8)
		roundedRectangle(screen[1]/2-string_size/2-25, screen[2]-logs[i].y:get(), string_size+10, 16, rr, gg, bb, 45,"", 7)
		roundedRectangle(screen[1]/2-string_size/2-25, screen[2]-logs[i].y:get(), string_size+10, 16, rr, gg, bb, 55,"", 6)
		roundedRectangle(screen[1]/2-string_size/2-25, screen[2]-logs[i].y:get(), string_size+10, 16, rr, gg, bb, 155,"", 5)

        roundedRectangle(screen[1]/2-string_size/2-25, screen[2]-logs[i].y:get(), string_size+10, 16, 11, 11, 11, 255, "", 4)
        renderer.text(screen[1]/2-20, screen[2]-logs[i].y:get()+8, 255,255,255,255, "c", 0, logs[i].text)

        if tonumber(logs[i].time) < globals.tickcount() then
            if logs[i].y:get() < -10 then
                table.remove(logs, i)
            else
                logs[i].y:update(globals.frametime(), -50, nil)
            end
        else
            logs[i].y:update(globals.frametime(), 20+(i*28), nil)
        end
		
    end
end)

slide_animation = function(s, v, t)
    return s + (v - s) * t
end

clamp = function(x, minval, maxval)
    if x < minval then
        return minval
    elseif x > maxval then
        return maxval
    else
        return x
    end
end

local cfunc = function(x) if x == nil then return 0 end x = (x % 360 + 360) % 360 return x > 180 and x - 360 or x end

local positions = {}
local lc = false

client.set_event_callback("setup_command", function(cmd)
    local plocal = entity.get_local_player()
    local origin = vector(entity.get_origin(plocal))
    local time = 1 / globals.tickinterval()

    if cmd.chokedcommands == 0 then
        positions[#positions + 1] = origin

        if #positions >= time then
            local record = positions[time]
            lc = (origin - record):lengthsqr() > 4096
        end
    end

    if #positions > time then
        table.remove(positions, 1)
    end
end)

local previous_tag = ''

client.set_event_callback("net_update_end", function()
    local local_player = entity.get_local_player()
    if not local_player or not ui.get(clantag) or ui.get(refs.clantag) then
        return
    end

    local clantag_restore = false

    if 0 then
        local animation = {
            "nemesis.lat",
            "n3m3sis.lat"
        }

        --local latency = math.floor(client.latency()*1000) / globals.tickinterval()
        local tickcount_prediction = globals.tickcount() + 1000
        local current_iteration = math.floor(math.fmod(tickcount_prediction / 50, #animation) + 1)

        if animation[current_iteration] ~= previous_tag then
            client.set_clan_tag(animation[current_iteration])
            previous_tag = animation[current_iteration]
        end
        clantag_restore = true
    elseif clantag_restore then
        client.set_clan_tag('')
    end
end)

client.set_event_callback("setup_command", function(cmd)
	local user_ground = bit.band(entity.get_prop(entity.get_local_player(), "m_fFlags"), 1) == 1
	
	if ui.get(fl_reset) then
		ui.set_visible(refs.fakelag, false)
		if user_ground == false then
			ui.set(refs.fakelag, true)
		elseif user_ground == true and client.key_state("0x20") then
			ui.set(refs.fakelag, false)
		end
	else
		ui.set_visible(refs.fakelag, true)
	end

end)

local function draw_indicator_circle(ctx, x, y, r, g, b, a, radius, percentage)
	client.draw_circle_outline(ctx, x, y, 0, 0, 0, 200, radius, 0, 1.0, 5)
	client.draw_circle_outline(ctx, x, y, r, g, b, a, radius - 1, 0, percentage, 3)
end

client.set_event_callback("paint", function(ctx)
    local localplayer = entity.get_local_player()
	local screen_size = {client.screen_size()}
	local rr, gg, bb = processColor(main_colour)
	local string_size = renderer.measure_text("c", ui.get(refs.minimumdamageoverride[3]))
	
    if not entity.is_alive(entity.get_local_player()) then return end

    if ui.get(refs.minimumdamageoverride[2]) and does_contain(ui.get(indicators), "minimum damage") then
		roundedRectangle(screen_size[1] / 2 + 7, screen_size[2] / 2 - 14, string_size-3, 6, rr, gg, bb, 35, "", 2)
		roundedRectangle(screen_size[1] / 2 + 7, screen_size[2] / 2 - 14, string_size-3, 6, rr, gg, bb, 45, "", 3)
		roundedRectangle(screen_size[1] / 2 + 7, screen_size[2] / 2 - 14, string_size-3, 6, rr, gg, bb, 55, "", 4)
		roundedRectangle(screen_size[1] / 2 + 7, screen_size[2] / 2 - 14, string_size-3, 6, rr, gg, bb, 105, "", 5)
        renderer.text(screen_size[1] / 2 + 5, screen_size[2] / 2 - 17, 255, 255, 255, 175, "db", 0, ui.get(refs.minimumdamageoverride[3]) .. "")
    end

	if does_contain(ui.get(indicators), "lag compensation") then
		local plocal = entity.get_local_player()
		local flags = entity.get_prop(plocal, "m_fFlags")
	
		if bit.band(flags, 1) == 1 and not lc or not entity.is_alive(plocal) then
			return
		end
	
		local r, g, b, a = 240, 15, 15, 240
	
		if lc then
			r, g, b = 160, 202, 43
		end
		
		renderer.indicator(r, g, b, a, "LC")
    end
end)

client.set_event_callback("setup_command", function(cmd)
	if ui.get(defensive) then
		cmd.force_defensive = globals.tickcount() % 3 ~= 1
	else
		return end
end)

local ground_ticks = 0
local char_ptr = ffi.typeof('char*')
local class_ptr = ffi.typeof('void***')
local nullptr = ffi.new('void*')
local native_GetClientEntity = vtable_bind('client.dll', 'VClientEntityList003', 3, 'void*(__thiscall*)(void*, int)')
local animation_layer_t = ffi.typeof([[
	struct {										char pad0[0x18];
		uint32_t	sequence;
		float		prev_cycle;
		float		weight;
		float		weight_delta_rate;
		float		playback_rate;
		float		cycle;
		void		*entity;						char pad1[0x4];
	} **
]])

client.set_event_callback("pre_render", function()
	
	if not entity.is_alive(entity.get_local_player()) then return end

	local pEnt = ffi.cast(class_ptr, native_GetClientEntity(entity.get_local_player()))
	if pEnt == nullptr then
		return
	end

	local anim_layers = ffi.cast(animation_layer_t, ffi.cast(char_ptr, pEnt) + 0x2990)[0][6]
	
	local user_ground = bit.band(entity.get_prop(entity.get_local_player(), "m_fFlags"), 1) == 1

	local lt = {[1] = "Off", [2] = "Always slide" , [3] = "Never slide"}

	if entity.get_prop(entity.get_local_player(), 'm_hGroundEntity') then
        ground_ticks = ground_ticks + 1
    else
        ground_ticks = 0
    end

	if ui.get(animbrk) then
		ui.set_visible(refs.leg_movement, false)
	else
		ui.set_visible(refs.leg_movement, true)
	end

	if ui.get(animbrk) and ui.get(animbrkwhat) == "modern" and not user_ground then
		entity.set_prop(entity.get_local_player(), 'm_flPoseParameter', 1, 6)
	elseif ui.get(animbrk) and ui.get(animbrkwhat) == "moonwalk" and not user_ground then
		anim_layers.weight = 1
	end

	if ui.get(animbrk) and ui.get(animbrkwhat) == "modern" then
		ui.set(refs.leg_movement, lt[math.random(2,3)])
		entity.set_prop(entity.get_local_player(), "m_flPoseParameter", math.random(0.1, 2), math.random(0,1)) 
	elseif ui.get(animbrk) and ui.get(animbrkwhat) == "moonwalk" then
		entity.set_prop(entity.get_local_player(), 'm_flPoseParameter', 0.5, 7)
		ui.set(refs.leg_movement, lt[3])
	end

	if ui.get(animbrk) and ui.get(animbrkpitch) == "0 pitch" and ground_ticks > 5 and ground_ticks < 300 then
		entity.set_prop(entity.get_local_player(), 'm_flPoseParameter', 0.5, 12)
	elseif ui.get(animbrk) and ui.get(animbrkpitch) == "0 pitch random" and ground_ticks > 5 and ground_ticks < 300 then
		entity.set_prop(entity.get_local_player(), 'm_flPoseParameter', math.random(0.5, 1), 12)
	end

end)

function anti_knife_dist(x1, y1, z1, x2, y2, z2)
    return math.sqrt((x2 - x1)^2 + (y2 - y1)^2 + (z2 - z1)^2)
end

client.set_event_callback("setup_command", function()
        local players = entity.get_players(true)

        local localoriginx, localoriginy, localoriginz = entity.get_prop(entity.get_local_player(), "m_vecOrigin")

        for i=1, #players do
            local playeroriginx, playeroriginy, playeroriginz = entity.get_prop(players[i], "m_vecOrigin")
			local vel_x, vel_y = entity.get_prop(entity.get_local_player(), "m_vecVelocity")
            local distance = anti_knife_dist(localoriginx, localoriginy, localoriginz, playeroriginx, playeroriginy, playeroriginz)

            local weapon = entity.get_player_weapon(players[i])
			if ui.get(antibackstab) then
				if entity.get_classname(weapon) == "CKnife" and distance <= 250 + math.abs(math.floor(math.sqrt(vel_x * vel_x + vel_y * vel_y + 1000))) / 3 then
					ui.set(refs.yaw[2], 180)
					ui.set(refs.pitch[1], "Off")
				end
		   end
	  end
end)

local function text_fade(x, y, s, c1, c2, text)
    local texxt = ''
    local curtime = globals.curtime()
    for i = 0, #text do
        local color = rgba_to_hex(
            slide_animation(c1.r, c2.r, clamp(math.cos(1 * s * curtime / 4 + i * 10  / 15), 0, 1)),
            slide_animation(c1.g, c2.g, clamp(math.cos(1 * s * curtime / 4 + i * 10  / 15), 0, 1)),
            slide_animation(c1.b, c2.b, clamp(math.cos(1 * s * curtime / 4 + i * 10  / 15), 0, 1)),
            c1.a
        ) 
        texxt = texxt .. '\a' .. color .. text:sub(i, i) 
    end
    renderer.text(x, y, c1.r, c1.g, c1.b, c1.a, "b", nil, texxt)
end

client.set_event_callback("paint", function()
	local screen_size = {client.screen_size()}
	local rr, gg, bb = processColor(main_colour)

	if ui.get(watermark) then
		text_fade(screen_size[1] / 2 + 860, screen_size[2] / 2, 15, {r=rr, g=gg, b=bb, a=255}, {r=255, g=255, b=255, a=255}, "N  E  M  E  S  I  S")
	end
end)

client.set_event_callback("setup_command", function(c)
	local tickcount = globals.tickcount()

	if ui.get(freestand_key) then
		ui.set(refs.freestand[1], true)
		ui.set(refs.freestand[2], "Always on")
	elseif ui.get(freestand_key) and ui.get(flick_fs) then
		ui.set(refs.freestand[1], true)
		ui.set(refs.freestand[2], "Always on")
		c.in_use = cfunc((tickcount % 18 < 2 and 1 or 0))
	else
		ui.set(refs.freestand[1], false)
		ui.set(refs.freestand[2], "Always on")
	end	

	local local_player = entity.get_local_player()
	local vel_x, vel_y = entity.get_prop(local_player, "m_vecVelocity")
	local user_standing = math.sqrt(vel_x ^ 2 + vel_y ^ 2) < 5
	local user_ground = bit.band(entity.get_prop(local_player, "m_fFlags"), 1) == 1 and c.in_jump == 0
	local user_slowmotion = ui.get(refs.slowmotion[1]) and ui.get(refs.slowmotion[2])
	local is_os = ui.get(refs.onshotaa[1]) and ui.get(refs.onshotaa[2])
	local is_dt = ui.get(refs.doubletap[1]) and ui.get(refs.doubletap[2])
	local is_fd = ui.get(refs.fakeduck)

	if not is_dt and not is_os or is_fd then
		state_vars.player_state_holder = 7
	elseif c.in_duck == 1 and user_ground then
		state_vars.player_state_holder = 5
	elseif c.in_duck == 1 and not user_ground then
		state_vars.player_state_holder = 6
	elseif not user_ground then
		state_vars.player_state_holder = 4
	elseif user_slowmotion then
		state_vars.player_state_holder = 3
	elseif user_standing then
		state_vars.player_state_holder = 1
	elseif not user_standing then
		state_vars.player_state_holder = 2
	end

	local bodyyaw = entity.get_prop(entity.get_local_player(), "m_flPoseParameter", 11) * 120 - 60
	local side = bodyyaw > 0 and 1 or -1

	local metapitch = {[1] = client.random_int(-65,-45), [2] = 89, [3] = 89, [4] = 89}
	local yawvaluer = {[1] = math.random(-50,50), [2] = math.random(-90,90), [3] = math.random(-120,120)}
	local randomyaw = client.random_int(69,169)

	if ui.get(antiaim_state) then
		if ui.get(dis_jitter) and ui.get(freestand_key) then
			ui.set(refs.pitch[1], "minimal")
			ui.set(refs.yaw[2], 0)
			ui.set(refs.yaw[1], "180")
			ui.set(refs.yawbase, "at targets")
			ui.set(refs.yawjitter[1], "off")
			ui.set(refs.yawjitter[2], 0)
			ui.set(refs.bodyyaw[1], "opposite")
			ui.set(refs.bodyyaw[2], 0)
		else
		ui.set(refs.yawbase, "at targets")
		ui.set(refs.bodyyaw[1], ui.get(Builder[state_vars.player_state_holder].bodyoptions))
		ui.set(refs.bodyyaw[2], ui.get(Builder[state_vars.player_state_holder].bodyoptionsslider))
		ui.set(refs.fsbodyyaw, false)
		ui.set(refs.yawjitter[1], ui.get(Builder[state_vars.player_state_holder].yawjitter))
		ui.set(refs.yawjitter[2], ui.get(Builder[state_vars.player_state_holder].yawjitterslider))

		if ui.get(Builder[state_vars.player_state_holder].pitch) == "spam" then
			ui.set(refs.pitch[1], "Custom")
			ui.set(refs.pitch[2], cfunc((tickcount % 6 < 3 and -89 or 89)))
		elseif ui.get(Builder[state_vars.player_state_holder].pitch) == "flicker" then
			ui.set(refs.pitch[1], "Custom")
			ui.set(refs.pitch[2], cfunc((tickcount % 30 < 2 and math.random(-89, -75) or 89)))
		else
			ui.set(refs.pitch[1], ui.get(Builder[state_vars.player_state_holder].pitch))
		end

		if ui.get(Builder[state_vars.player_state_holder].yaw) == "l + r" then
			if c.chokedcommands == 0 then
				ui.set(refs.yaw[1], "180")
				ui.set(refs.yaw[2], (side == 1 and ui.get(Builder[state_vars.player_state_holder].yawleft) or ui.get(Builder[state_vars.player_state_holder].yawright)))
			end
		elseif ui.get(Builder[state_vars.player_state_holder].yaw) == "spam" then
			ui.set(refs.yaw[1], "180")
			ui.set(refs.yaw[2], cfunc((tickcount % 6 < 3 and randomyaw or -randomyaw)))
		elseif ui.get(Builder[state_vars.player_state_holder].yaw) == "delay" then
			if ui.get(Builder[state_vars.player_state_holder].unsafedelay) then
				ui.set(refs.yaw[1], "180")
			    ui.set(refs.yaw[2], cfunc((tickcount % 18 < 11 and ui.get(Builder[state_vars.player_state_holder].yawleft) or ui.get(Builder[state_vars.player_state_holder].yawright))))
			else
				ui.set(Builder[state_vars.player_state_holder].yawjitter, "off")
			    ui.set(Builder[state_vars.player_state_holder].bodyoptions, "off")
			    ui.set(refs.yaw[1], "180")
			    ui.set(refs.yaw[2], cfunc((tickcount % 18 < 11 and ui.get(Builder[state_vars.player_state_holder].yawleft) or ui.get(Builder[state_vars.player_state_holder].yawright))))
		end
	  end
	end
  end
end)

local hitgroup_names = {
    "generic", "head", "chest", "stomach", "left arm", "right arm", "left leg", "right leg", "neck", "unknown"
}

client.set_event_callback("aim_fire", function(event)
    stored_shot = {
		id = event.id,
        damage = event.damage,
        hitbox = hitgroup_names[event.hitgroup + 1],
        lagcomp = event.teleported,
        backtrack = globals.tickcount() - event.tick,
		hitchance = event.hit_chance,
		flags = {
			event.teleported and 'T' or '',
			event.interpolated and 'I' or '',
			event.extrapolated and 'E' or '',
			event.boosted and 'B' or '',
			event.high_priority and 'H' or ''
		}
    }
end)

client.set_event_callback("aim_miss", function(event)
	local output = {}
	local actualhc = math.floor(event.hit_chance)

    if ui.get(hitlogs) then
		if event.reason == "?" then
			output = string.format("MISS(%s) / %s / %s / %s / resolver / [aim=%s bt=%s]", stored_shot.id, entity.get_player_name(event.target), stored_shot.hitbox, stored_shot.damage, hitgroup_names[event.hitgroup + 1], stored_shot.backtrack)
		elseif event.reason == "?" and 0 > stored_shot.backtrack then
			output = string.format("MISS(%s) / %s / %s / %s / forwardtrack failure / [aim=%s bt=%s]", stored_shot.id, entity.get_player_name(event.target), stored_shot.hitbox, stored_shot.damage, hitgroup_names[event.hitgroup + 1], stored_shot.backtrack)
		elseif event.reason == "?" and 10 < stored_shot.backtrack then
			output = string.format("MISS(%s) / %s / %s / %s / backtrack failure / [aim=%s bt=%s]", stored_shot.id, entity.get_player_name(event.target), stored_shot.hitbox, stored_shot.damage, hitgroup_names[event.hitgroup + 1], stored_shot.backtrack)
		else
			output = string.format("MISS(%s) / %s / %s / %s / %s / [aim=%s bt=%s]", stored_shot.id, entity.get_player_name(event.target), stored_shot.hitbox, stored_shot.damage, event.reason, hitgroup_names[event.hitgroup + 1], stored_shot.backtrack)
		end

	print(output)
	table.insert(logs, { text = output, rr = 255, gg = 50, bb = 50 })
  end
end)

client.set_event_callback("aim_hit", function(event)
	local output = {}
	local actualhc = math.floor(event.hit_chance)

	if ui.get(hitlogs) then
		output = string.format("HIT(%s) / %s / %s / %s(%s) / [aim=%s bt=%s mismatch=%s]", stored_shot.id, entity.get_player_name(event.target), hitgroup_names[event.hitgroup + 1], event.damage, stored_shot.damage, stored_shot.hitbox, stored_shot.backtrack, (event.damage >= stored_shot.damage) and "FALSE" or "TRUE")
	print(output)
	table.insert(logs, { text = output, rr = 150, gg = 200, bb = 59 })
  end
end)

local killphrases = {
	'WEKE JUST UPDATED NEMESIS FOR SKEET TO V5 AND ITS POWER‚ó£_‚ó¢‚ó£_‚ó¢‚ó£_‚ó¢',
	'WEKE JUST UPDATED NEMESIS FOR SKEET TO V5 AND ITS POWER‚ó£_‚ó¢‚ó£_‚ó¢‚ó£_‚ó¢',
	'WEKE JUST UPDATED NEMESIS FOR SKEET TO V5 AND ITS POWER‚ó£_‚ó¢‚ó£_‚ó¢‚ó£_‚ó¢',
	'WEKE JUST UPDATED NEMESIS FOR SKEET TO V5 AND ITS POWER‚ó£_‚ó¢‚ó£_‚ó¢‚ó£_‚ó¢',
	'WEKE JUST UPDATED NEMESIS FOR SKEET TO V5 AND ITS POWER‚ó£_‚ó¢‚ó£_‚ó¢‚ó£_‚ó¢',
	'WEKE JUST UPDATED NEMESIS FOR SKEET TO V5 AND ITS POWER‚ó£_‚ó¢‚ó£_‚ó¢‚ó£_‚ó¢',
	'WEKE JUST UPDATED NEMESIS FOR SKEET TO V5 AND ITS POWER‚ó£_‚ó¢‚ó£_‚ó¢‚ó£_‚ó¢',
	'WEKE JUST UPDATED NEMESIS FOR SKEET TO V5 AND ITS POWER‚ó£_‚ó¢‚ó£_‚ó¢‚ó£_‚ó¢',
	'WEKE JUST UPDATED NEMESIS FOR SKEET TO V5 AND ITS POWER‚ó£_‚ó¢‚ó£_‚ó¢‚ó£_‚ó¢',
	'WEKE JUST UPDATED NEMESIS FOR SKEET TO V5 AND ITS POWER‚ó£_‚ó¢‚ó£_‚ó¢‚ó£_‚ó¢',
	'WEKE JUST UPDATED NEMESIS FOR SKEET TO V5 AND ITS POWER‚ó£_‚ó¢‚ó£_‚ó¢‚ó£_‚ó¢',
	'WEKE JUST UPDATED NEMESIS FOR SKEET TO V5 AND ITS POWER‚ó£_‚ó¢‚ó£_‚ó¢‚ó£_‚ó¢',
	'helo my naim ist WEKE me is use DEVELOPER VERSION of nemesis.lat!!!!!!',
	'ùñäùñìùñèùñîùñû ùñâùñéùñä ùñôùñî nemesis ùñëùñöùñÜ ùñòùñêùñóùñéùñïùñô',
	'nemesis ùìãùìà ùìÉùìÉ ùíæùìà ùìåùíæùìÉ ùìàùëú ùëíùí∂ùìàùìé',
	'ùïûùï™ ùïîùïôùïñùïíùï• ùïöùï§ ùï¶ùï§ùïñ ùïüùïñùïûùïñùï§ùïöùï§ ùï£ùïñùï§ùï†ùïùùïßùïñùï£ ùïíùïüùïï ùïôùïñùïïùï§ùïôùï†ùï•',
	'ÔΩéÔΩâÔΩÉÔΩÖ ÔΩçÔΩâÔΩìÔΩì ÔΩÑÔΩèÔΩá ÔΩèÔΩóÔΩéÔΩÖÔΩÑ Ôºë',
	' ô è …¥·¥á·¥ç·¥áÍú±…™Íú±',
	' ∑ ∞·µâ‚Åø ·µç·µÉ·µê·µâ À¢·µó·µÉ ≥·µó  ∏·µí·µò ‚Å±À¢ À°·µíÀ¢·µâ ·µÉÀ° ≥·µâ·µÉ·µà ∏',
	'ùêÆùê´ ùê•ùêÆùêö ùêúùê´ùêöùêúùê§ùêûùêù ùê•ùê¢ùê§ùêû ùêûùê†ùê†',
	'Y”®–¶ Œõ–ØŒ£–ü∆¨ –©I–ü ∆ß–ØY.',
	'‚ô• after contact sigma i hs and smile ‚ô•',
	'ùñãùñóùñäùñä ùñçùñõùñç 2020-2022 ùñëùñäùñòùñòùñîùñì ùñûùñîùñöùñôùñöùñáùñä.ùñàùñîùñí/makihvh',
	'ÔΩáÔΩèÔΩÑ ÔΩâÔΩì ÔΩáÔΩâÔΩñÔΩÖ ÔΩçÔΩÖ ÔΩêÔΩèÔΩóÔΩÖÔΩí ÔΩîÔΩè ÔΩàÔΩÖÔΩÅÔΩÑÔΩìÔΩàÔΩèÔΩî ÔΩôÔΩèÔΩï',
	'you is owned by nemesis lua for ùñåùñÜùñíùñäùñòùñäùñìùñòùñä',
	'1',
	'privat doubltap peak solution ‚ó£_‚ó¢',
	'ùñöùñó ùñÜùñìùñôùñéùñÜùñéùñíùñáùñîùñô ùñéùñò ùñòùñîùñëùñõùñä ùñáùñû ùñóùñäùñòùñîùñëùñõùñäùñó ùïüùïñùïûùïñùï§ùïöùï§ ‚ó£_‚ó¢‚ó£_‚ó¢‚ó£_‚ó¢',
	'sowwy >_<',
	'ùï®ùïôùïñùïü ùïö ùï£ùïñùïîùïñùïöùïß ùïìùïñùï•ùïí ùïüùïñùïûùïñùï§ùïöùï§ LUASH ùïö +ùï® ùïöùïüùï•ùï† ùï¶ (‚ó£_‚ó¢)',
	'ÔΩÖÔΩòÔΩÖÔΩÉÔΩïÔΩîÔΩÖ ÔΩíÔΩÅÔΩîÔºéÔΩÖÔΩòÔΩÖ ÔΩÑÔΩèÔΩéÔΩÖÔºé',
	'ùñôùñóùñîùñëùñëùñäùñâ‚ó£__‚ó¢',
	'ùï®ùïôùïñùïü ùïö ùï§ùïñùïñ ùï®ùïñùïúùïñ ùïö ùï£ùïñùï°ùï†ùï£ùï• ùï°ùï£ùïöùïûùï†ùï£ùïïùïöùïíùïù ùïíùïîcùï†ùïüùï• (‚ó£_‚ó¢)',
	'ùï®ùïôùïñùïü ùïö ùï§ùïñùïñ ùï®ùïñùïúùïñ ùïö ùï£ùïñùï°ùï†ùï£ùï• ùï°ùï£ùïöùïûùï†ùï£ùïïùïöùïíùïù ùïíùïîcùï†ùïüùï• (‚ó£_‚ó¢)',
	'ùï®ùïôùïñùïü ùïö ùï§ùïñùïñ ùï®ùïñùïúùïñ ùïö ùï£ùïñùï°ùï†ùï£ùï• ùï°ùï£ùïöùïûùï†ùï£ùïïùïöùïíùïù ùïíùïîcùï†ùïüùï• (‚ó£_‚ó¢)',
	'ùï®ùïôùïñùïü ùïö ùï§ùïñùïñ ùï®ùïñùïúùïñ ùïö ùï£ùïñùï°ùï†ùï£ùï• ùï°ùï£ùïöùïûùï†ùï£ùïïùïöùïíùïù ùïíùïîcùï†ùïüùï• (‚ó£_‚ó¢)',
	'when i see weke uid 386 on primordial i report his prim account axaxax (‚ó£_‚ó¢)',
	'when i see weke uid 386 on primordial i report his prim account axaxax (‚ó£_‚ó¢)',
	'when i see weke uid 386 on primordial i report his prim account axaxax (‚ó£_‚ó¢)',
	'when i see weke uid 386 on primordial i report his prim account axaxax (‚ó£_‚ó¢)',
	'when i see weke uid 386 on primordial i report his prim account axaxax (‚ó£_‚ó¢)',
	'when i see weke uid 386 on primordial i report his prim account axaxax (‚ó£_‚ó¢)',
	'uu  á«ù«ù ûs  énq o…ì «ùsn «ù ás…êd …ìop «ù…îƒ±u',
	'ùîΩ‚Ñùùîºùîº ùïÉùïåùî∏ ùïãùïÜùïÑùïÜ‚Ñù‚ÑùùïÜùïé!',
	'ùïòùï®ùïíùïûùïñùï§ùï®ùïñùïüùï§ùïñ ùî∏‚ÑïùïãùïÄ-ùî∏ùïÄùïÑ ‚Ñçùîºùî∏ùîªùïä‚ÑçùïÜùïã ‚Ñô‚ÑùùîºùîªùïÄ‚ÑÇùïã',
	'ùîÇùì∏ùìæ ùì±ùì™ùìøùìÆ ùìæùì∑ùìæùìºùìÆùì≠ ùì≤ùì∑ùìøùì≤ùìΩùì™ùìΩùì≤ùì∏ùì∑ ùì¨ùì∏ùì≠ùìÆùìº ‚ó£_‚ó¢',
	'·¥°·¥Ä Ä…¥…™…¥…¢: …¢·¥è…™…¥…¢ ·¥õ·¥è Íú± ü·¥á·¥á·¥ò ·¥è…¥ Íú±·¥ú…¥·¥Ö·¥Ä è ·¥°…™ ü ü ·¥Ñ·¥Ä·¥úÍú±·¥á ·¥ç·¥è…¥·¥Ö·¥Ä è',
	'ùïùùïñùïòùïöùï• ùïöùï§ ùï•ùï¶ùï£ùïü ùïöùïü ùïôùïßùïô ùïûùïíùï•ùïîùïôùïíùïûùïúùïöùïüùïò ùïóùï•. ùï†ùï•ùïîùïßùüö (‚ó£_‚ó¢)',
	'ùìºùì∏ ùì≤ ùì∂ùì≤ùì∞ùì±ùìΩ ùì´ùìÆ ùìºùìÆùìµùìµùì≤ùì∑ùì∞ ùì∑ùìÆùìøùìÆùìªùìµùì∏ùìºùìÆ ùì≤ùì∑ùìøùì≤ùìΩùì™ùìΩùì≤ùì∏ùì∑...',
	'ùüôùïßùüô ùïßùï§ ùïïùïñùïïùï°ùï†ùïù ùïöùï§ ùï®ùïöùïü ùïìùïñùïîùï¶ùï§ ùïôùïñ ùïíùï£ùïñ ùïüùï†ùï• ùï¶ùï§ùïñ ùïíùïïùïíùï°ùï•ùïöùïßùïñ ‚ó£_‚ó¢',
	'ùï®ùïôùïñùïü ùïö ùïñùï©ùïöùï•ùï§ùïîùïíùïû ùïíùïüùïï ùïìùïíùïü ùï•ùïôùïñ ùïîùï†ùïïùïñùï£ ùïö ùïôùï§ ùïíùïüùïï ùï§ùïûùïöùïùùïñ',
	'ùï®ùïôùïñùïü ùïö ùïñùï©ùïöùï•ùï§ùïîùïíùïû ùïíùïüùïï ùïìùïíùïü ùï•ùïôùïñ ùïîùï†ùïïùïñùï£ ùïö ùïôùï§ ùïíùïüùïï ùï§ùïûùïöùïùùïñ',
	'ùï®ùïôùïñùïü ùïö ùïñùï©ùïöùï•ùï§ùïîùïíùïû ùïíùïüùïï ùïìùïíùïü ùï•ùïôùïñ ùïîùï†ùïïùïñùï£ ùïö ùïôùï§ ùïíùïüùïï ùï§ùïûùïöùïùùïñ',
	'ùï®ùïôùïñùïü ùïö ùïñùï©ùïöùï•ùï§ùïîùïíùïû ùïíùïüùïï ùïìùïíùïü ùï•ùïôùïñ ùïîùï†ùïïùïñùï£ ùïö ùïôùï§ ùïíùïüùïï ùï§ùïûùïöùïùùïñ',
	'ùï®ùïôùïñùïü ùïö ùïñùï©ùïöùï•ùï§ùïîùïíùïû ùïíùïüùïï ùïìùïíùïü ùï•ùïôùïñ ùïîùï†ùïïùïñùï£ ùïö ùïôùï§ ùïíùïüùïï ùï§ùïûùïöùïùùïñ',
	'ùï®ùïôùïñùïü ùïö ùïñùï©ùïöùï•ùï§ùïîùïíùïû ùïíùïüùïï ùïìùïíùïü ùï•ùïôùïñ ùïîùï†ùïïùïñùï£ ùïö ùïôùï§ ùïíùïüùïï ùï§ùïûùïöùïùùïñ',
	'ùï®ùïôùïñùïü ùïö ùïñùï©ùïöùï•ùï§ùïîùïíùïû ùïíùïüùïï ùïìùïíùïü ùï•ùïôùïñ ùïîùï†ùïïùïñùï£ ùïö ùïôùï§ ùïíùïüùïï ùï§ùïûùïöùïùùïñ',
	'LUCKBOOST.CFG <-- UR CFG RN',
	'LUCKBOOST.CFG <-- UR CFG RN',
	'LUCKBOOST.CFG <-- UR CFG RN',
	"ùïôùïñùïôùïñùïôùïñ, ùï¶ ùïòùï£ùïíùïì ùïûùï™ ùïóùïíùïùùïù ùïòùï¶ùï™ùï§ ùïîùïôùïíùï£ùïíùïîùï•ùïñ ",
	"ùïôùïñùïôùïñùïôùïñ, ùï¶ ùïòùï£ùïíùïì ùïûùï™ ùïóùïíùïùùïù ùïòùï¶ùï™ùï§ ùïîùïôùïíùï£ùïíùïîùï•ùïñ ",
	"ùïîùï†ùïûùïñ ùïûùïñùïñùï• ùïûùï™ ùïôùïñùïùùïùùï† ùïúùïöùï•ùï•ùï™ ùï•ùïñùïíùïû >.<",
	"ùïîùï†ùïûùïñ ùïûùïñùïñùï• ùïûùï™ ùïôùïñùïùùïùùï† ùïúùïöùï•ùï•ùï™ ùï•ùïñùïíùïû >.<",
	"ùïîùï†ùïûùïñ ùïûùïñùïñùï• ùïûùï™ ùïôùïñùïùùïùùï† ùïúùïöùï•ùï•ùï™ ùï•ùïñùïíùïû >.<",
	"ùí∏ùëúùìÇùëí ùìÇùëíùëíùìâ ùìÇùìé ùíΩùëíùìÅùìÅùëú ùìÄùíæùìâùìâùìé ùìâùëíùí∂ùìÇ >.<",
	"ùí∏ùëúùìÇùëí ùìÇùëíùëíùìâ ùìÇùìé ùíΩùëíùìÅùìÅùëú ùìÄùíæùìâùìâùìé ùìâùëíùí∂ùìÇ >.<",
	"ùí∏ùëúùìÇùëí ùìÇùëíùëíùìâ ùìÇùìé ùíΩùëíùìÅùìÅùëú ùìÄùíæùìâùìâùìé ùìâùëíùí∂ùìÇ >.<",
	"WHEN IM MAKIHVH I EXITSCAM FOR 1 EURO AND SMILE‚òπ‚òπ",
	"WHEN IM MAKIHVH I EXITSCAM FOR 1 EURO AND SMILE‚òπ‚òπ",
	"WHEN IM MAKIHVH I EXITSCAM FOR 1 EURO AND SMILE‚òπ‚òπ",
	"WHEN IM MAKIHVH I EXITSCAM FOR 1 EURO AND SMILE‚òπ‚òπ",
	"WHEN IM MAKIHVH I EXITSCAM FOR 1 EURO AND SMILE‚òπ‚òπ",
	"WHEN IM MAKIHVH I EXITSCAM FOR 1 EURO AND SMILE‚òπ‚òπ",
	"ùï®ùïôùïñùïü ùïö ùïûùïñùïñùï• ùïìùï£ùïíùï•ùïßùïí ùïö ùï§ùïíùï™ ùüô ùïìùïöùïîùï¶ùï´ ùïöùïû ùï§ùïöùïòùïûùïí",
	"ùï®ùïôùïñùïü ùïö ùïûùïñùïñùï• ùïìùï£ùïíùï•ùïßùïí ùïö ùï§ùïíùï™ ùüô ùïìùïöùïîùï¶ùï´ ùïöùïû ùï§ùïöùïòùïûùïí",
	"ùï®ùïôùïñùïü ùïö ùïûùïñùïñùï• ùïìùï£ùïíùï•ùïßùïí ùïö ùï§ùïíùï™ ùüô ùïìùïöùïîùï¶ùï´ ùïöùïû ùï§ùïöùïòùïûùïí",
	"ùï®ùïôùïñùïü ùïö ùïûùïñùïñùï• ùïìùï£ùïíùï•ùïßùïí ùïö ùï§ùïíùï™ ùüô ùïìùïöùïîùï¶ùï´ ùïöùïû ùï§ùïöùïòùïûùïí",
	"WHEN I SEE ORCUS.RAT/BRATVA POP UP ON MY PC I DIE FROM LAUGHTER",
	"WHEN I SEE ORCUS.RAT/BRATVA POP UP ON MY PC I DIE FROM LAUGHTER",
	"GAMSNZ ACCUNT STOLEN SUCESSFULLY BY LIMEPOLISH",
	"GAMSNZ ACCUNT STOLEN SUCESSFULLY BY LIMEPOLISH",
	"GAMSNZ ACCUNT STOLEN SUCESSFULLY BY LIMEPOLISH",
	"GAMSNZ ACCUNT STOLEN SUCESSFULLY BY LIMEPOLISH",
	"ùêøùêºùëÄùê∏ùí´ùí™ùêøùêºùíÆùêª: !ùíÆùíûùëÖùê∏ùê∏ùí©ùíÆùêªùí™ùíØ",
	"ùêøùêºùëÄùê∏ùí´ùí™ùêøùêºùíÆùêª: !ùíÆùíûùëÖùê∏ùê∏ùí©ùíÆùêªùí™ùíØ",
	"ùêøùêºùëÄùê∏ùí´ùí™ùêøùêºùíÆùêª: !ùíÆùíûùëÖùê∏ùê∏ùí©ùíÆùêªùí™ùíØ",
	"*DEAD* ‚òÇ nossa vei : i need a good wanheda.red cfg",
	"*DEAD* ‚òÇ nossa vei : i need a good wanheda.red cfg",
	"*DEAD* ‚òÇ nossa vei : i need a good wanheda.red cfg",
	"*DEAD* ‚òÇ nossa vei : i need a good wanheda.red cfg"
}

local function get_table_length(data)
  if type(data) ~= 'table' then
    return 0
  end
  local count = 0
  for _ in pairs(data) do
    count = count + 1
  end
  return count
end

local killphrases_length = get_table_length(killphrases)

local function on_player_death(e)
	local victim_userid, attacker_userid = e.userid, e.attacker
	if victim_userid == nil or attacker_userid == nil then return end

	local victim_entindex = client.userid_to_entindex(victim_userid)
	local attacker_entindex = client.userid_to_entindex(attacker_userid)

	if attacker_entindex == entity.get_local_player() and entity.is_enemy(victim_entindex) and ui.get(shittalk) then
		local commandbaim = 'say ' .. killphrases[math.random(killphrases_length)]
		client.exec(commandbaim)
	end
end

client.set_event_callback("player_death", on_player_death)

local alphabet = "base64"

local function system_export()
	local export = {}
	for key, value in pairs(state_vars.short_player_states) do
		export[tostring(value)] = {}
		for k, v in pairs(Builder[key]) do
			export[value][k] = ui.get(v)
		end
	end
	local exported = json.stringify(export)
	local encoded = base64.encode(exported, alphabet)
	clipboard.set(encoded)
	table.insert(logs, {
		text = "Config Exported.",
		rr = 191,
				gg = 191,
				bb = 236
	})
end

local function system_import()
	local imported = json.parse(base64.decode(clipboard.get(), alphabet))
	for key, value in pairs(state_vars.short_player_states) do
		for k, v in pairs(Builder[key]) do
			local current = imported[value][k]
			if (current ~= nil) then
				ui.set(v, current)
			end
		end
	end
	table.insert(logs, {
		text = "Config Imported.",
		rr = 191,
				gg = 191,
				bb = 236
	})
end

local function extractKey(jsonString)
    local keyStart = string.find(jsonString, ':"') -- Find the position where the key starts
    local keyEnd = string.find(jsonString, '"}', keyStart + 2) -- Find the position where the key ends

    if keyStart and keyEnd then
        return string.sub(jsonString, keyStart + 2, keyEnd - 1) -- Extract the substring containing the key value
    else
        return nil
    end
end

local function system_export_pastebin()
	local export = {}
	for key, value in pairs(state_vars.short_player_states) do
		export[tostring(value)] = {}
		for k, v in pairs(Builder[key]) do
			export[value][k] = ui.get(v)
		end
	end
	
	local exported = json.stringify(export)
	local encoded = base64.encode(exported, alphabet)
	local text_depend = ""
	http.post("https://hastebin.skyra.pw/documents", { body = ""..encoded.."", headers = { ['Content-Type'] = 'application/x-www-form-urlencoded' } }, function(success, response)
        if success then
			table.insert(logs, {
				text = "Config uploaded, link in console.",
				rr = 191,
				gg = 191,
				bb = 236
			})
			print("https://hastebin.skyra.pw/raw/"..extractKey(response.body)..".txt")
			clipboard.set("https://hastebin.skyra.pw/raw/"..extractKey(response.body)..".txt")
        else
			table.insert(logs, {
				text = "Connection failed. Contact staff.",
				rr = 234,
				gg = 147,
				bb = 190
			})
        end
    end)
end

local button_import = ui.new_button("AA", "Anti-aimbot angles",defhex.."import", system_import)
local button_export = ui.new_button("AA", "Anti-aimbot angles",defhex.."export", system_export)
local button_export_pst = ui.new_button("AA", "Anti-aimbot angles",defhex.."export + upload", system_export_pastebin)

local function config_apply()
	
	state_vars.active_section = state_vars.state_int[ui.get(current_state_select)]
	local is_aa = ui.get(lua_menu) == 2
	local is_rage = ui.get(lua_menu) == 1
	local is_vis = ui.get(lua_menu) == 3
	local is_misc = ui.get(lua_menu) == 4
	local is_aabden = ui.get(antiaim_state)

	if is_aabden and is_aa then
		ui.set_visible(button_import, true)
		ui.set_visible(button_export, true)
		ui.set_visible(button_export_pst, true)
	else
		ui.set_visible(button_import, false)
		ui.set_visible(button_export, false)
		ui.set_visible(button_export_pst, false)
	end

end

client.set_event_callback("paint_ui", lua_apply)
client.set_event_callback("paint_ui", og_apply)
client.set_event_callback("paint_ui", config_apply)
client.set_event_callback("shutdown", function()
	og_apply(true)
	ui.set_visible(refs.fakelag, true)
	ui.set_visible(refs.leg_movement, true)
end)

client.set_event_callback("paint_ui", function()
	og_apply(false)
end)

client.set_event_callback("paint_ui", gradient_rgbslide)
